alias stow='stow --ignore \.git'
alias n='nvim'
alias nv='neovide'
alias v='vim'
alias hx='helix'
alias rm='trash-put'

function cdj() { curl -s https://icanhazdadjoke.com/ }
function cbb() { curl -s https://api.breakingbadquotes.xyz/v1/quotes | jq -r '.[] | "\"\(.quote)\" -- \(.author)"' }
function bbq() { curl -s https://api.breakingbadquotes.xyz/v1/quotes | jq -r '.[] | "\"\(.quote)\" -- \(.author)"' |  cowsay -f ~/.cowsay-cows/walter-white.cow }
function fal() { rg -e "^\s*alias" ~/i3df/.zshrc.alias | fzf }

alias doo='~/i3df/scripts/doing.sh'
alias font-list='fc-list | fzf'
alias fdir='cd $(find * -type d | fzf)' # Change directory with interactive search
alias fps='ps aux | fzf' # Search through running processes
alias gb='git branch | fzf | xargs git checkout' # Git-specific fuzzy commands
alias gl='git log --oneline | fzf --preview "git show --color=always {1}"'
alias fk='ps aux | fzf | awk "{print \$2}" | xargs kill -9' # Kill process interactively
alias fcd='cd $(find . -type d | fzf)' # Search and cd into subdirectories

alias fQ='yay -Q | fzf'

alias feh='feh --scale-down'
alias ytvc='yt-dlp --write-subs -P "$HOME/videos/" "$(xclip -selection c -o 2>/dev/null)"'
alias ytmc='yt-dlp --write-subs --extract-audio --audio-quality 0 --embed-thumbnail -P "$HOME/music/" "$(xclip -selection c -o 2>/dev/null)"'
alias ytv='yt-dlp -P "$HOME/videos/" '
alias ytm='yt-dlp --extract-audio --audio-quality 0 --embed-thumbnail -P "$HOME/music/"'
alias ll='eza --icons --color=auto -alh'
alias l='eza --icons --color=auto -h'
alias tree='tree -a -I .git'
alias od="ouch decompress"
alias oc="ouch   compress"
# alias So='source ~/.zshrc'
alias So='exec zsh'
alias fcr='kill `ps -A | grep fcitx5 | awk '{print $1}'` && ( fcitx5 & )'
alias grep='grep --color=auto'

alias cona='nvim ~/i3df/.zshrc.alias'
alias conb='nvim ~/i3df/.bashrc'
alias cond='cd ~/i3df/.config/dunst; nvim dunstrc'
alias cone='cd ~/.config/doom/; nvim .'
alias coni='cd ~/i3df/.config/i3/; nvim config'
alias const='nvim ~/i3df/.config/i3blocks/config'
alias conm='nvim ~/.config/mimeapps.list'
alias conn='cd ~/i3df/.config/nvim/lua/plugins/; yazi'
alias conq='cd ~/.config/qutebrowser; yazi .'
alias cons='cd ~/i3df/scripts; yazi .'
alias conw='nvim ~/i3df/.config/wezterm/wezterm.lua'
alias con.='yazi ~/.config/'
alias cony='cd ~/.config/yazi/; nvim .'
alias conz='nvim ~/i3df/.zshrc'

alias N='cd ~/notes; y'
alias Nha='nvim ~/notes/hobby/anime/'
alias Nc='nvim ~/notes/code/'

alias nnp='nvim --cmd "let g:pluginless = 1"'
alias b='btop'
alias py='python'
alias py3='python3'
alias pya='source env/bin/activate'
alias pyi='pip install -r requirements.txt'
alias pyenv='python3 -m venv;'
alias pyenvi='python3 -m venv env; pya; pyi;'
alias Sp='sudo pacman -S'
alias ys='yay -S'
alias lg='lazygit'
alias gi3='cd ~/i3df/; lazygit;'
alias setclip='xclip -selection c'
alias getclip='xclip -selection c -o'
alias sc='xclip -selection c'
alias gc='xclip -selection c -o'
alias retroarch='(retroarch &)'
alias DR='pkill dunst; ( dunst & ); sleep 1; notify-send -u low 'low"; notify-send -u normal "normal"; notify-send -u critical "critical";" 
# alias sudo='mpv ~/i3df/scripts/notify/bell.mp3; sudo'

alias RB='cd ~/FUTSALA/; source env/bin/activate; uvicorn backend.main:app --reload'
alias RF='cd ~/FUTSALA/frontend; npm run dev'
alias RC='cd ~/FUTSALA; nvim .'
alias hql='harlequin'
alias xrr='xrandr --output HDMI-1 --right-of eDP-1'
alias xr0='xrandr -s 0'
alias xrm='xrandr --setmonitor HDMI-1~1 768/205x683/230+1366+0 HDMI-1;
xrandr --setmonitor HDMI-1~2 768/205x683/230+1366+683 none'
alias xro='xrandr --output HDMI-1 --mode 1366x768 --pos 1366x0 --rotate right'
alias xrd='xrandr --delmonitor HDMI-1~1; xrandr --delmonitor HDMI-1~2'
alias xr='xrd; xrm'

# rg
# --field-match-separator ' ' - tell rg to separate the filename and linenumber with
# spaces to play well with fzf, (when recognizing index variables to use in the fzf
# preview command, fzf uses a default delimiter of space, see below)

# fzf
# --preview window ~8,+{1}-5
#   this is a fzf feature
#   ~8 - show first 8 lines (header)
#   +{2} - fzf delimits the input piped in to it and provides access via index variables {n}. 
#   the default delimiter fzf uses is space but can be specified via --delimiter <delimiter>
#   pass the second index variable from bat (which is the line number)
#   the number is signed, you can show eg the +n row or the -n row (the nth row from the bottom)
#   -5 subtract 5 rows (go up 5 rows) so that you don't show the highlighted line as the first line
#   since you want to provide context by showing the rows above the highlighted line
mkcd () {
  mkdir -p -- "$1" &&
    cd -P -- "$1"
  }

  fman() {
    man -k . | fzf -q "$1" --prompt='man> '  --preview $'echo {} | tr -d \'()\' | awk \'{printf "%s ", $2} {print $1}\' | xargs -r man | col -bx | bat -l man -p --color always' | tr -d '()' | awk '{printf "%s ", $2} {print $1}' | xargs -r man
  }

# f() {
#     # Store the program
#     program="$1"
#
#     # Remove first argument off the list
#     shift
#
#     # Store option flags with separating spaces, or just set as single space
#     options="$@"
#     if [ -z "${options}" ]; then
#         options=" "
#     else
#         options=" $options "
#     fi
#
#     # Store the arguments from fzf
#     arguments="$(fzf --multi)"
#
#     # If no arguments passed (e.g. if Esc pressed), return to terminal
#     if [ -z "${arguments}" ]; then
#         return 1
#     fi
#
#     # We want the command to show up in our bash history, so write the shell's
#     # active history to ~/.bash_history. Then we'll also add the command from
#     # fzf, then we'll load it all back into the shell's active history
#     history -w
#
#     # ADD A REPEATABLE COMMAND TO THE BASH HISTORY ############################
#     # Store the arguments in a temporary file for sanitising before being
#     # entered into bash history
#     : > /tmp/fzf_tmp
#     for file in "${arguments[@]}"; do
#         echo "$file" >> /tmp/fzf_tmp
#     done
#
#     # Put all input arguments on one line and sanitise the command by putting
#     # single quotes around each argument, also first put an extra single quote
#     # next to any pre-existing single quotes in the raw argument
#     sed -i "s/'/''/g; s/.*/'&'/g; s/\n//g" /tmp/fzf_tmp
#
#     # If the program is on the GUI list, add a '&' to the command history
#     if [[ "$program" =~ ^(nautilus|zathura|evince|vlc|eog|kolourpaint)$ ]]; then
#         sed -i '${s/$/ \&/}' /tmp/fzf_tmp
#     fi
#
#     # Grab the sanitised arguments
#     arguments="$(cat /tmp/fzf_tmp)"
#
#     # Add the command with the sanitised arguments to our .bash_history
#     echo $program$options$arguments >> ~/.bash_history
#
#     # Reload the ~/.bash_history into the shell's active history
#     history -r
#
#     # EXECUTE THE LAST COMMAND IN ~/.bash_history #############################
#     fc -s -1
#
#     # Clean up temporary variables
#     rm /tmp/fzf_tmp
# }
#
#
#

# absolutely game changer bindings 
function displayFZFFiles {
  echo $(fzf --multi --preview 'bat --color=always --style=header,grid --line-range :400 {}')
}

function ff {
  selection=$(displayFZFFiles);
  if [ -z "$selection" ]; then
    return;
  else
    echo "$selection" | xargs -r nvim
  fi;
}

# Function to open nvim at specific line using fzf with bat preview
function fw() {
  local selected=$(rg --line-number \
    --no-heading \
    --color=always \
    --smart-case \
    . 2> /dev/null |
    fzf --delimiter ':' \
    --ansi \
    --prompt 'rg> ' \
    --preview 'bat --style=numbers --color=always --highlight-line {2} {1}' \
    --preview-window 'down,45%,+{2}+3/3,~3')

  if [[ -n "$selected" ]]; then
    local file="${${(s/:/)selected}[1]}"
    local line="${${(s/:/)selected}[2]}"
    nvim "$file" "+$line"
  fi
}
function fwa() {
  local selected=$(rga --line-number \
    --no-heading \
    --color=always \
    --smart-case \
    . 2> /dev/null |
    fzf --delimiter ':' \
    --ansi \
    --prompt 'rga> ' \
    --preview 'bat --style=numbers --color=always --highlight-line {2} {1}' \
    --preview-window 'down,45%,+{2}+3/3,~3')

  if [[ -n "$selected" ]]; then
    local file="${${(s/:/)selected}[1]}"
    local line="${${(s/:/)selected}[2]}"
    nvim "$file" "+$line"
  fi
}
